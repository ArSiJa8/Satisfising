<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Interactive Particle Flow — Audio Reactive + MP4 Export</title>
<style>
:root{--panel:rgba(255,255,255,0.06);--accent:#7ee7c6}
*{box-sizing:border-box}
html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial}
body{background:linear-gradient(180deg,#020417 0%, #07102a 60%);overflow:hidden;color:#dff6f0}
canvas{display:block}
.ui{position:fixed;right:18px;top:18px;width:380px;background:var(--panel);backdrop-filter:blur(8px);border-radius:12px;padding:12px;color:#e6f0ef;box-shadow:0 8px 40px rgba(2,8,23,0.7);max-height:88vh;overflow:auto}
.header{display:flex;gap:8px;align-items:center}
.header h1{font-size:15px;margin:0}
.row{display:flex;gap:8px;align-items:center;margin:8px 0}
label{font-size:12px;flex:1}
input[type=range]{width:170px}
.btn{appearance:none;border:0;background:linear-gradient(90deg,var(--accent),#6bd8ff);color:#012;padding:8px;border-radius:8px;font-weight:700;cursor:pointer}
.small{font-size:12px;padding:6px;border-radius:6px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.03);cursor:pointer}
.details{margin-top:8px}
.preset-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:8px}
.preset-thumb{width:100%;height:64px;border-radius:6px;overflow:hidden;border:1px solid rgba(255,255,255,0.03);cursor:pointer}
.footer-credit{position:fixed;right:18px;bottom:18px;color:#7ee7c6;font-size:12px;opacity:0.95}
.small-input{width:72px}
.top-controls{display:flex;gap:8px}
</style>
</head>
<body>
<canvas id="mainCanvas"></canvas>
<div class="ui" id="ui">
  <div class="header">
    <h1>Interactive Particle Flow — Audio Reactive</h1>
  </div>

  <div class="top-controls" style="margin-top:8px">
    <button id="playPause" class="btn">Pause</button>
    <button id="micBtn" class="small">Enable Mic</button>
    <button id="uploadLabel" class="small">Upload Audio</button>
    <input id="audioFile" type="file" accept="audio/*" style="display:none">
  </div>

  <div class="row"><label>Particles <span id="countLabel">900</span></label><input id="count" type="range" min="100" max="5000" step="50" value="900"></div>
  <div class="row"><label>Speed <span id="speedLabel">1.0</span></label><input id="speed" type="range" min="0" max="4" step="0.01" value="1"></div>
  <div class="row"><label>Chaos (noise) <span id="noiseLabel">0.85</span></label><input id="noise" type="range" min="0" max="3" step="0.01" value="0.85"></div>
  <div class="row"><label>Trail decay <span id="decayLabel">0.1</span></label><input id="decay" type="range" min="0" max="0.6" step="0.005" value="0.1"></div>
  <div class="row"><label>Attractor strength <span id="attrLabel">300</span></label><input id="attractor" type="range" min="0" max="3000" step="10" value="300"></div>

  <div class="row"><label>Blend mode</label>
    <select id="blend"><option value="lighter">Additive</option><option value="source-over" selected>Normal</option><option value="multiply">Multiply</option><option value="screen">Screen</option></select>
  </div>

  <div class="row"><label>Color scheme</label>
    <select id="scheme"><option value="teal">Teal Reef</option><option value="sunset">Sunset</option><option value="violet">Violet Nebula</option><option value="rainbow">Rainbow</option></select>
  </div>

  <details open class="details"><summary><strong>Presets & Gallery</strong></summary>
    <div style="margin-top:8px;display:flex;gap:8px;align-items:center;">
      <div style="flex:1">
        <select id="presetSelect" style="width:100%"><option value="none">— choose preset —</option><option value="galaxy">Galaxy</option><option value="jellyfish">Jellyfish</option><option value="fireworks">Fireworks</option><option value="aurora">Aurora</option></select>
      </div>
      <button id="applyPreset" class="small">Apply</button>
    </div>
    <div class="preset-grid" id="presetGrid"></div>
    <div style="margin-top:8px">Share: <button id="copyUrl" class="small">Copy URL</button> <button id="importUrl" class="small">Load from URL</button></div>
  </details>

  <details class="details"><summary><strong>Advanced</strong></summary>
    <div class="row"><label>Flow scale <span id="fscaleLabel">0.6</span></label><input id="flowScale" type="range" min="0.1" max="2" step="0.01" value="0.6"></div>
    <div class="row"><label>Particle size variance <span id="psizeLabel">1.8</span></label><input id="pSize" type="range" min="0.2" max="4" step="0.01" value="1.8"></div>
    <div class="row"><label>Color shift speed <span id="cshiftLabel">1.0</span></label><input id="colorShift" type="range" min="0" max="3" step="0.01" value="1"></div>
    <div class="row"><label>Audio gain <span id="gainLabel">1.0</span></label><input id="gain" type="range" min="0" max="5" step="0.01" value="1"></div>
    <div class="row"><label>Bass sensitivity <span id="bassLabel">1.0</span></label><input id="bass" type="range" min="0" max="5" step="0.01" value="1"></div>
    <div class="row"><label>Smoothing <span id="smoothLabel">0.8</span></label><input id="smoothing" type="range" min="0" max="0.99" step="0.01" value="0.8"></div>
  </details>

  <div style="display:flex;gap:8px;margin-top:8px">
    <button id="regen" class="btn">New Seed</button>
    <button id="clear" class="small">Clear</button>
    <button id="savePng" class="small">Save PNG</button>
  </div>

  <div style="margin-top:10px;font-size:12px;opacity:0.9">Tip: click/drag to add attractors. Double-click clears attractors. Use mic or upload an audio file — press <strong>Start Recording</strong> to capture MP4 (includes audio).</div>

  <div style="margin-top:8px;display:flex;gap:8px">
    <button id="startRec" class="btn">Start Recording</button>
    <button id="stopRec" class="small">Stop Recording</button>
  </div>

</div>

<div class="footer-credit">ArSiJa Studios</div>

<script>
// Full single-file visualization + audio + recording + presets
'use strict';

// Canvas & resize
const canvas = document.getElementById('mainCanvas');
const ctx = canvas.getContext('2d');
let W = canvas.width = innerWidth;
let H = canvas.height = innerHeight;
window.addEventListener('resize', ()=>{ W = canvas.width = innerWidth; H = canvas.height = innerHeight; build(); });

// UI refs
const ui = {
  count: document.getElementById('count'), speed: document.getElementById('speed'), noise: document.getElementById('noise'), decay: document.getElementById('decay'), attractor: document.getElementById('attractor'), blend: document.getElementById('blend'), scheme: document.getElementById('scheme'), regen: document.getElementById('regen'), clear: document.getElementById('clear'), savePng: document.getElementById('savePng'),
  micBtn: document.getElementById('micBtn'), audioFile: document.getElementById('audioFile'), uploadLabel: document.getElementById('uploadLabel'),
  playPause: document.getElementById('playPause'), startRec: document.getElementById('startRec'), stopRec: document.getElementById('stopRec'), copyUrl: document.getElementById('copyUrl'), importUrl: document.getElementById('importUrl'),
  // advanced
  flowScale: document.getElementById('flowScale'), pSize: document.getElementById('pSize'), colorShift: document.getElementById('colorShift'), gain: document.getElementById('gain'), bass: document.getElementById('bass'), smoothing: document.getElementById('smoothing'),
  // labels
  labels: { count: document.getElementById('countLabel'), speed: document.getElementById('speedLabel'), noise: document.getElementById('noiseLabel'), decay: document.getElementById('decayLabel'), attr: document.getElementById('attrLabel'), fscale: document.getElementById('fscaleLabel'), psize: document.getElementById('psizeLabel'), cshift: document.getElementById('cshiftLabel'), gain: document.getElementById('gainLabel'), bass: document.getElementById('bassLabel'), smooth: document.getElementById('smoothLabel') }
};

// Presets
const presets = {
  galaxy:{count:1200,speed:0.6,noise:0.3,decay:0.08,attractor:900,blend:'lighter',scheme:'violet',flowScale:0.4,pSize:2.2,colorShift:0.8,gain:0.7,bass:1.2,smoothing:0.85},
  jellyfish:{count:700,speed:0.9,noise:1.2,decay:0.08,attractor:250,blend:'source-over',scheme:'teal',flowScale:0.6,pSize:1.6,colorShift:1.4,gain:1.6,bass:1.8,smoothing:0.9},
  fireworks:{count:2000,speed:2.2,noise:2.2,decay:0.14,attractor:1200,blend:'lighter',scheme:'rainbow',flowScale:0.9,pSize:2.6,colorShift:2.8,gain:2.4,bass:1.0,smoothing:0.75},
  aurora:{count:1000,speed:0.8,noise:0.9,decay:0.06,attractor:400,blend:'screen',scheme:'teal',flowScale:0.3,pSize:1.8,colorShift:1.2,gain:1.0,bass:1.4,smoothing:0.88}
};

// build preset thumbnails
const presetGrid = document.getElementById('presetGrid');
Object.keys(presets).forEach(key => {
  const div = document.createElement('div'); div.className='preset-thumb'; div.title = key;
  presetGrid.appendChild(div);
  renderPresetThumb(div, presets[key]);
  div.addEventListener('click', ()=>{ applyPreset(key); });
});

function renderPresetThumb(el, p){
  const w = 160, h = 64; const off = document.createElement('canvas'); off.width=w; off.height=h; const g = off.getContext('2d');
  // simple gradient bg
  g.fillStyle = '#050816'; g.fillRect(0,0,w,h);
  // tiny randomized dots as a thumbnail
  for(let i=0;i<150;i++){
    const x = Math.random()*w; const y = Math.random()*h; const r = Math.random()*2.2;
    const hue = p.scheme==='teal'?190:(p.scheme==='sunset'?30:(p.scheme==='violet'?270:Math.random()*360));
    g.fillStyle = `hsl(${hue} ${60+Math.random()*30}% ${40+Math.random()*20}%)`;
    g.beginPath(); g.arc(x,y,r,0,Math.PI*2); g.fill();
  }
  el.style.backgroundImage = `url(${off.toDataURL()})`;
}

// RNG
let seed = Math.floor(Math.random()*1e9);
let rng = mulberry32(seed);
function mulberry32(a){ return function(){ a |=0; a = a + 0x6D2B79F5 | 0; var t = Math.imul(a ^ a>>>15, 1 | a); t = t + Math.imul(t ^ t>>>7, 61 | t) ^ t; return ((t ^ t>>>14) >>> 0) / 4294967296; } }

// noise
function makeNoise(width,height,cell){ const cols = Math.ceil(width/cell)+2; const rows = Math.ceil(height/cell)+2; const grid = new Array(cols*rows).fill(0).map(_=>rng()); return (x,y)=>{ const fx=x/cell, fy=y/cell, cx=Math.floor(fx), cy=Math.floor(fy), tx=fx-cx, ty=fy-cy; const idx=(i,j)=>i+j*cols; function lerp(a,b,t){return a+(b-a)*(t*(3-2*t));} const a=grid[idx(cx,cy)], b=grid[idx(cx+1,cy)], c=grid[idx(cx,cy+1)], d=grid[idx(cx+1,cy+1)]; const ab=lerp(a,b,tx), cd=lerp(c,d,tx); return lerp(ab,cd,ty); }; }

// Particles
class Particle { constructor(){ this.reset(); } reset(){ this.x=rng()*W; this.y=rng()*H; this.vx=0; this.vy=0; this.life=0; this.maxLife=60+Math.floor(rng()*340); this.h=rng(); this.size=1 + rng()*parseFloat(ui.pSize.value); } step(dt, audioInf){ const n = flowNoise(this.x*parseFloat(ui.flowScale.value), this.y*parseFloat(ui.flowScale.value)); const angle = n * Math.PI * 4.0 * parseFloat(ui.noise.value); const fx = Math.cos(angle), fy = Math.sin(angle); let ax=0, ay=0; for(const A of attractors){ const dx=A.x-this.x, dy=A.y-this.y, d2=dx*dx+dy*dy+0.0001; const force = parseFloat(ui.attractor.value) * A.strength / d2; ax += dx * force; ay += dy * force; } const speed = parseFloat(ui.speed.value); this.vx += (fx*0.6 + ax) * 0.023 * speed * dt; this.vy += (fy*0.6 + ay) * 0.023 * speed * dt; this.vx += audioInf.x * dt * 0.5; this.vy += audioInf.y * dt * 0.5; this.vx *= 0.985; this.vy *= 0.985; this.x += this.vx * dt; this.y += this.vy * dt; this.life++; if(this.x < -200 || this.x > W+200 || this.y < -200 || this.y > H+200 || this.life > this.maxLife) this.reset(); } }

let particles = [], attractors = [], flowNoise;
let last = performance.now(); let playing = true; let alphaDecay = parseFloat(ui.decay.value);

// Audio state
let audioState = { enabled:false, audioCtx:null, analyser:null, dataArray:null, source:null, element:null, destination:null, smoothed:0 };

// Build function
function build(){ W = canvas.width = innerWidth; H = canvas.height = innerHeight; flowNoise = makeNoise(W,H,80); const num = parseInt(ui.count.value); particles = new Array(num).fill(0).map(()=> new Particle()); }

// Color
function colorFor(t){ const scheme = ui.scheme.value; const cshift = parseFloat(ui.colorShift.value); if(scheme==='teal'){ const a=(Math.sin(t*6.283*cshift+1.2)+1)/2; return `hsl(${160+a*40} ${70+a*20}% ${40+a*20}%)`; } else if(scheme==='sunset'){ const a=(Math.sin(t*6.283*cshift+0.8)+1)/2; return `hsl(${20+a*60} ${60+a*30}% ${45+a*20}%)`; } else if(scheme==='violet'){ const a=(Math.sin(t*6.283*cshift+2.1)+1)/2; return `hsl(${260+a*30} ${50+a*30}% ${40+a*20}%)`; } else { return `hsl(${(t*360*cshift)%360}deg 70% 55%)`; } }

// Audio analysis
function enableMic(){ if(audioState.enabled) return; navigator.mediaDevices.getUserMedia({audio:true}).then(stream=>{
  audioState.audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  audioState.source = audioState.audioCtx.createMediaStreamSource(stream);
  audioState.analyser = audioState.audioCtx.createAnalyser(); audioState.analyser.fftSize = 2048; const bufferLength = audioState.analyser.frequencyBinCount; audioState.dataArray = new Uint8Array(bufferLength);
  audioState.destination = audioState.audioCtx.createMediaStreamDestination(); // for recording
  audioState.source.connect(audioState.analyser);
  audioState.source.connect(audioState.destination);
  audioState.enabled = true; document.getElementById('micBtn').textContent='Mic On';
}).catch(e=>{ console.warn('mic failed',e); document.getElementById('micBtn').textContent='Mic Failed'; }); }

function useAudioFile(file){ // create audio element
  if(audioState.element){ audioState.element.pause(); audioState.element.remove(); audioState.element = null; }
  const url = URL.createObjectURL(file);
  const audio = new Audio(url); audio.crossOrigin='anonymous'; audio.loop=false; audio.controls=true; audio.style.display='none'; document.body.appendChild(audio); audio.play(); audioState.element = audio;
  if(!audioState.audioCtx){ audioState.audioCtx = new (window.AudioContext||window.webkitAudioContext)(); }
  if(audioState.source) try{ audioState.source.disconnect(); }catch(e){}
  audioState.source = audioState.audioCtx.createMediaElementSource(audio);
  audioState.analyser = audioState.audioCtx.createAnalyser(); audioState.analyser.fftSize = 2048; const bufferLength = audioState.analyser.frequencyBinCount; audioState.dataArray = new Uint8Array(bufferLength);
  audioState.destination = audioState.audioCtx.createMediaStreamDestination(); audioState.source.connect(audioState.analyser); audioState.source.connect(audioState.destination); audioState.enabled = true;
  document.getElementById('micBtn').textContent = 'Audio Loaded';
}

function getAudioInfluence(){ if(!audioState.enabled || !audioState.analyser) return {x:0,y:0}; audioState.analyser.getByteFrequencyData(audioState.dataArray); const arr = audioState.dataArray; const len = arr.length; let low=0,mid=0,high=0; for(let i=0;i<len;i++){ const v=arr[i]; if(i<len*0.2) low+=v; else if(i<len*0.6) mid+=v; else high+=v; } low /= len*0.2; mid /= len*0.4; high /= len*0.4; const weighted = low*parseFloat(ui.bass.value) + mid*0.5 + high*0.2; audioState.smoothed = audioState.smoothed * parseFloat(ui.smoothing.value) + weighted*(1-parseFloat(ui.smoothing.value)); const g = parseFloat(ui.gain.value); const magnitude = (audioState.smoothed/255) * g; // direction can be influenced by avg phase
  const angle = Math.random()*Math.PI*2; return {x: Math.cos(angle)*magnitude*6, y: Math.sin(angle)*magnitude*6}; }

// render loop
function frame(now){ const dt = Math.min(60, now-last)/16.6667; last = now; if(!playing){ requestAnimationFrame(frame); return; } ctx.globalCompositeOperation='source-over'; ctx.fillStyle = `rgba(3,6,12,${alphaDecay})`; ctx.fillRect(0,0,W,H); ctx.globalCompositeOperation = ui.blend.value; const audioInf = getAudioInfluence(); for(let i=0;i<particles.length;i++){ const p = particles[i]; p.step(dt,audioInf); const age = (p.life / p.maxLife); const t = (p.h + age) % 1; const color = colorFor(t); ctx.beginPath(); ctx.fillStyle = color; const r = p.size * (1 + Math.sin(age*3.14)*0.8); ctx.arc(p.x,p.y,r,0,Math.PI*2); ctx.fill(); ctx.lineWidth = Math.max(0.2,r*0.6); ctx.strokeStyle = color; ctx.beginPath(); ctx.moveTo(p.x - p.vx*2, p.y - p.vy*2); ctx.lineTo(p.x,p.y); ctx.stroke(); }
  ctx.globalCompositeOperation='lighter'; for(const A of attractors){ const grad = ctx.createRadialGradient(A.x,A.y,0,A.x,A.y,60); grad.addColorStop(0,'rgba(255,255,255,0.9)'); grad.addColorStop(0.3,'rgba(255,255,255,0.2)'); grad.addColorStop(1,'rgba(0,0,0,0)'); ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(A.x,A.y,60,0,Math.PI*2); ctx.fill(); }
  requestAnimationFrame(frame);
}

// UI wiring
ui.count.addEventListener('input', e=>{ ui.labels.count.textContent = e.target.value; build(); });
ui.speed.addEventListener('input', e=> ui.labels.speed.textContent = parseFloat(e.target.value).toFixed(2));
ui.noise.addEventListener('input', e=> ui.labels.noise.textContent = parseFloat(e.target.value).toFixed(2));
ui.decay.addEventListener('input', e=>{ ui.labels.decay.textContent = parseFloat(e.target.value).toFixed(3); alphaDecay = parseFloat(e.target.value); });
ui.attractor.addEventListener('input', e=> ui.labels.attr.textContent = e.target.value);
ui.flowScale.addEventListener('input', e=> ui.labels.fscale.textContent = parseFloat(e.target.value).toFixed(2));
ui.pSize.addEventListener('input', e=> ui.labels.psize.textContent = parseFloat(e.target.value).toFixed(2));
ui.colorShift.addEventListener('input', e=> ui.labels.cshift.textContent = parseFloat(e.target.value).toFixed(2));
ui.gain.addEventListener('input', e=> ui.labels.gain.textContent = parseFloat(e.target.value).toFixed(2));
ui.bass.addEventListener('input', e=> ui.labels.bass.textContent = parseFloat(e.target.value).toFixed(2));
ui.smoothing.addEventListener('input', e=> ui.labels.smooth.textContent = parseFloat(e.target.value).toFixed(2));

document.getElementById('presetSelect').addEventListener('change', (e)=>{ const v=e.target.value; if(v!=='none') applyPreset(v); });

document.getElementById('applyPreset').addEventListener('click', ()=>{ const v=document.getElementById('presetSelect').value; if(v!=='none') applyPreset(v); });

function applyPreset(key){ const p = presets[key]; if(!p) return; ui.count.value=p.count; ui.speed.value=p.speed; ui.noise.value=p.noise; ui.decay.value=p.decay; ui.attractor.value=p.attractor; ui.blend.value=p.blend; ui.scheme.value=p.scheme; ui.flowScale.value=p.flowScale; ui.pSize.value=p.pSize; ui.colorShift.value=p.colorShift; ui.gain.value=p.gain; ui.bass.value=p.bass; ui.smoothing.value=p.smoothing; // update labels
  ui.labels.count.textContent=p.count; ui.labels.speed.textContent=p.speed.toFixed(2); ui.labels.noise.textContent=p.noise.toFixed(2); ui.labels.decay.textContent=p.decay.toFixed(3); ui.labels.attr.textContent=p.attractor; ui.labels.fscale.textContent=p.flowScale.toFixed(2); ui.labels.psize.textContent=p.pSize.toFixed(2); ui.labels.cshift.textContent=p.colorShift.toFixed(2); ui.labels.gain.textContent=p.gain.toFixed(2); ui.labels.bass.textContent=p.bass.toFixed(2); ui.labels.smooth.textContent=p.smoothing.toFixed(2); // rebuild
  rng = mulberry32(Math.floor(Math.random()*1e9)); build(); }

// Copy/Import URL settings
ui.copyUrl.addEventListener('click', ()=>{ const settings = collectSettings(); const hash = encodeURIComponent(JSON.stringify(settings)); const url = location.origin + location.pathname + '#settings=' + hash; navigator.clipboard.writeText(url).then(()=>{ ui.copyUrl.textContent='Copied!'; setTimeout(()=> ui.copyUrl.textContent='Copy URL',1200); }); });

ui.importUrl.addEventListener('click', ()=>{ const m = location.hash.match(/settings=(.*)/); if(!m){ alert('No settings found in URL hash. Paste a URL with settings.'); return; } try{ const s = JSON.parse(decodeURIComponent(m[1])); applySettings(s); }catch(e){ alert('Failed to parse settings'); } });

function collectSettings(){ return { count:ui.count.value, speed:ui.speed.value, noise:ui.noise.value, decay:ui.decay.value, attractor:ui.attractor.value, blend:ui.blend.value, scheme:ui.scheme.value, flowScale:ui.flowScale.value, pSize:ui.pSize.value, colorShift:ui.colorShift.value, gain:ui.gain.value, bass:ui.bass.value, smoothing:ui.smoothing.value, seed }; }
function applySettings(s){ if(!s) return; ui.count.value=s.count||ui.count.value; ui.speed.value=s.speed||ui.speed.value; ui.noise.value=s.noise||ui.noise.value; ui.decay.value=s.decay||ui.decay.value; ui.attractor.value=s.attractor||ui.attractor.value; ui.blend.value=s.blend||ui.blend.value; ui.scheme.value=s.scheme||ui.scheme.value; ui.flowScale.value=s.flowScale||ui.flowScale.value; ui.pSize.value=s.pSize||ui.pSize.value; ui.colorShift.value=s.colorShift||ui.colorShift.value; ui.gain.value=s.gain||ui.gain.value; ui.bass.value=s.bass||ui.bass.value; ui.smoothing.value=s.smoothing||ui.smoothing.value; seed = s.seed || seed; rng = mulberry32(seed); // update labels
  ui.labels.count.textContent = ui.count.value; ui.labels.speed.textContent = parseFloat(ui.speed.value).toFixed(2); ui.labels.noise.textContent = parseFloat(ui.noise.value).toFixed(2); ui.labels.decay.textContent = parseFloat(ui.decay.value).toFixed(3); ui.labels.attr.textContent = ui.attractor.value; ui.labels.fscale.textContent = parseFloat(ui.flowScale.value).toFixed(2); ui.labels.psize.textContent = parseFloat(ui.pSize.value).toFixed(2); ui.labels.cshift.textContent = parseFloat(ui.colorShift.value).toFixed(2); ui.labels.gain.textContent = parseFloat(ui.gain.value).toFixed(2); ui.labels.bass.textContent = parseFloat(ui.bass.value).toFixed(2); ui.labels.smooth.textContent = parseFloat(ui.smoothing.value).toFixed(2); build(); }

// Mouse / touch interactions
let isDown=false; canvas.addEventListener('mousedown', e=>{ isDown=true; addAttractor(e.clientX,e.clientY); }); canvas.addEventListener('mousemove', e=>{ if(isDown) addAttractor(e.clientX,e.clientY,0.9); }); canvas.addEventListener('mouseup', ()=> isDown=false); canvas.addEventListener('dblclick', ()=> attractors=[]);
canvas.addEventListener('touchstart', e=>{ e.preventDefault(); isDown=true; const t=e.touches[0]; addAttractor(t.clientX,t.clientY); }); canvas.addEventListener('touchmove', e=>{ e.preventDefault(); const t=e.touches[0]; addAttractor(t.clientX,t.clientY,0.9); }); canvas.addEventListener('touchend', e=>{ e.preventDefault(); isDown=false; });
function addAttractor(x,y,str=1.0){ attractors.push({x,y,strength:str}); if(attractors.length>12) attractors.shift(); }

// Play/pause
ui.playPause.addEventListener('click', ()=>{ playing = !playing; ui.playPause.textContent = playing ? 'Pause' : 'Resume'; if(playing) last = performance.now(); });

// mic / upload handling
ui.uploadLabel.addEventListener('click', ()=> ui.audioFile.click());
ui.audioFile.addEventListener('change', e=>{ const f = e.target.files[0]; if(f) useAudioFile(f); });
ui.micBtn.addEventListener('click', ()=>{ if(!audioState.enabled) enableMic(); else { // disconnect
  if(audioState.audioCtx) audioState.audioCtx.close(); audioState = { enabled:false, audioCtx:null, analyser:null, dataArray:null, source:null, element:null, destination:null, smoothed:0 }; document.getElementById('micBtn').textContent='Enable Mic'; } });

// Screenshot
ui.savePng.addEventListener('click', ()=>{ const a = document.createElement('a'); a.href = canvas.toDataURL('image/png'); a.download = `particle-flow-${Date.now()}.png`; a.click(); });

// New seed / clear
ui.regen.addEventListener('click', ()=>{ seed = Math.floor(Math.random()*1e9); rng = mulberry32(seed); build(); });
ui.clear.addEventListener('click', ()=>{ ctx.clearRect(0,0,W,H); });

// Recording (canvas + audio)
let recorder = null; let recordedChunks = [];
ui.startRec.addEventListener('click', async ()=>{
  // assemble stream: canvas + audio
  const canvasStream = canvas.captureStream(60);
  let audioStream = null;
  if(audioState.enabled && audioState.destination){ audioStream = audioState.destination.stream; }
  // if audio element but no destination (older browsers), try capture via MediaElement
  if(!audioStream && audioState.element){ try{ audioStream = audioState.element.captureStream(); }catch(e){} }
  // merge
  const combined = new MediaStream();
  canvasStream.getVideoTracks().forEach(t=> combined.addTrack(t));
  if(audioStream){ audioStream.getAudioTracks().forEach(t=> combined.addTrack(t)); }

  // choose mime type: prefer mp4 if supported, else webm
  let mimeType = '';
  const options = ['video/mp4','video/webm;codecs=vp9,opus','video/webm;codecs=vp8,opus','video/webm'];
  for(const o of options){ if(MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(o)){ mimeType = o; break; } }
  if(!mimeType) mimeType = ''; // browser decides

  try{
    recordedChunks = [];
    recorder = new MediaRecorder(combined, mimeType ? {mimeType} : undefined);
  }catch(err){
    try{ recorder = new MediaRecorder(combined); }catch(e){ alert('Recording not supported in this browser'); console.error(e); return; }
  }
  recorder.ondataavailable = ev=>{ if(ev.data && ev.data.size>0) recordedChunks.push(ev.data); };
  recorder.onstop = ()=>{ const blob = new Blob(recordedChunks, {type: recorder.mimeType || 'video/webm'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; // attempt to name .mp4 if mime contains mp4
    const ext = recorder.mimeType && recorder.mimeType.includes('mp4') ? 'mp4' : 'webm'; a.download = `particle-flow-${Date.now()}.${ext}`; a.click(); setTimeout(()=> URL.revokeObjectURL(url), 10000); };
  recorder.start(); ui.startRec.textContent='Recording...';
});

ui.stopRec.addEventListener('click', ()=>{ if(recorder && recorder.state==='recording'){ recorder.stop(); ui.startRec.textContent='Start Recording'; } });

// init
build(); ctx.fillStyle='#02040a'; ctx.fillRect(0,0,W,H); requestAnimationFrame(frame);

// load settings from hash if exists
(function(){ if(location.hash.includes('settings=')){ try{ const h = location.hash.match(/settings=(.*)/); const s = JSON.parse(decodeURIComponent(h[1])); applySettings(s); }catch(e){ console.warn('failed to load settings'); } } })();

</script>
</body>
</html>
